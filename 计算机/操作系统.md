### 1. 什么是进程和线程，两者有什么区别？
##### (1)含义
- **进程**
> 正在运行的程序，它是操作系统进行资源分配和调度的独立单位，是可以独立运行的一段程序。
- **线程**
> 是进程的一个实体，是CPU分配和调度的基本单位，是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

##### (2)区别： 
- **划分尺度**：线程的划分尺度小于进程，所以多线程程序的并发性高；  
- **内存空间**：进程拥有独立的内存单元，同一进程所属线程共享内存；  
- **执行过程**：每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口；线程不能够独立执行，必须组成进程；一个程序至少有一个进程,一个进程至少有一个线程；  
- **逻辑角度**：进程是资源分配和调度的基本单位，线程是cpu分配和调度的基本单位。  

##### (3) 联系：
- **并发性**：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。
- **资源**：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

##### (4) 优缺点
- 线程执行开销小，但不利于资源的管理和维护；进程相反。
- 线程适合在SMP(对称多处理)机器上运行，而进程可以跨机器运行。

### 2. 父子进程、孤儿进程
##### (1) 父子进程
> 进程P创建了进程C之后，P就是C的父进程，子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，继承父进程所分配到的缓冲区等。为了标识进程之间的家族关系，在PCB(进程控制块) 中都设置了家族关系表项，以标明自己的父进程及所有的子进程。

##### (2)孤儿进程
> 当一个父进程由于正常完成工作而退出或由于其他情况被终止，它的一个或多个子进程却还在运行，那么那些子进程将成为孤儿进程；这些孤儿进程将被init进程(进程号为1，所有进程的父进程/祖先进程)所收养，并由init进程对它们完成状态收集工作。

##### (3)僵尸进程
> 如果一个进程已经终止了，但是其父进程还没有获取其状态，那么这个进程就称之为僵尸进程。僵尸进程放弃了几乎所有内存空间，除了在进程列表中保留了一个位置，记载了状态信息，一旦父进程得到想要的信息，僵尸进程就会结束。

##### (4)守护进程
> 守护进程就是在后台运行，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，能处理一些系统级的任务。

### 3. 进程间通信的方式有哪几种？线程呢？
##### (1) (无名)管道
> 用于父子进程、兄弟进程间。一种半双工通信方式，数据只能单向移动，只能在具有血缘的关系间使用。

##### (2)命名管道
> 可用于无关的进程之间。半双工。

##### (3)信号量
> 实现进程间互斥与同步。是一个计数器，用来控制多个进程对共享资源的访问，主要作为进程间和同一进程内不同线程间的同步手段。

##### (4)消息队列
> 存放在内核中，独立于进程。由消息组成的链表，并由消息消息队列标识服进行标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

##### (5)共享内存
> 多个进程共享一个给定存储区，但要保持同步，通常结合信号量使用

##### (6)套接字socket
> 实现不同主机上两个进程的通信

线程：共享内存、消息传递

### 4. 操作系统什么情况下会死锁？
##### (1)竞争不可剥夺资源
> 当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足各进程的需要时，会引起诸进程对资源的竞争而产生死锁。

##### (2)进程间推进顺序非法
> 进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。


### 5. 代码段、数据段、BSS(Block Started by Symbol)段、堆、栈（帮助理解其他内容）
#### 可执行代码存储时结构：
- 代码段：存放机器指令，通常只读
- 数据段：存放已初始化的全局变量、静态变量、常量
- BSS段：存放未初始化的全局变量

#### 正在运行的程序占用内存：
- 代码段
- 数据段
- BSS段：被内核初始化为0或者空指针(null)
- 栈区：存放函数的参数值、局部变量、函数的返回地址和关于调用的信息（寄存器的内容）
- 堆区：动态内存分配

#### 堆和栈的区别：
##### (1)管理方式不同：
> 空间的申请、释放：栈由编译器管理；堆由程序员管理

##### (2)空间大小、增长方向不同：
> 栈：栈顶地址和栈的最大容量由系统预先规定，栈是向低地址扩展的数据结构，是一块连续的内存区域；  
> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。

##### (3)是否产生碎片：
> 栈：连续的内存区域，不存在内存碎片；  
> 堆：频繁的空间申请、释放，造成内存空间的不连续，产生大量的碎片

##### (4)分配效率不同：
> 栈：是系统提供的数据结构，计算机会在底层对栈提供支持；  
> 堆：的效率比栈要低得多

##### (5) 存储内容不同
> 栈： 支持java方法，存储方法入口、参数、出口信息等  
堆：存储对象实例和数组

##### (6) 是否线程私有
> 栈：线程私有  
> 堆：线程共享

### 4. fork进程时的操作
一个进程，包括代码段、数据段、堆、栈。
##### (1)fork()函数通过系统调用创建一个与原来进程完全相同的子进程，可以通过fork的返回值来判断当前进程是子进程还是父进程。
fork()被调用一次，却能够返回两次，它可能有三种不同的返回值：
- ①在父进程中，fork返回新创建子进程的进程ID；
- ②在子进程中，fork返回0；
- ③如果出现错误，fork返回一个负值；  

fork出错可能有两种原因：
- ①当前的进程数已经达到了系统规定的上限；
- ②系统内存不足；  

(2)**刚开始**，子进程继承了父进程的数据段、代码段、栈、堆，从父进程继承来的是虚拟地址空间，同时也复制了页表。因此，此时父子进程拥有相同的虚拟地址，映射的物理内存也是一致的（独立的虚拟地址空间，共享父进程的物理内存），物理页面标记为“只读”。  

(3)**一旦父或子进程试图对某页执行写操作**，相应的页会复制到新的页给此进程，原来的页给另一进程——写时复制；写时复制只会对数据段、堆栈段发生，代码段（只读）始终共享物理内存；  

(4)**一旦子进程调用exec（执行不同于父进程的代码）**，会清空栈、堆，重新加载新的代码段，子进程的代码段也会分配单独的物理内存；父进程同时独自拥有了原来共享的物理内存（可读写）。

注：父子进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略；不过，内核一般会先调度子进程，因为很多情况下子进程是要马上执行exec，如果父进程先调度很可能会产生“写时复制”的无用功。所以，一般是子进程先调度。

### 6. 进程调度算法
##### (1)先来先服务 （FCFS，first come first served）
- **算法原理**：每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配CPU，使之投入运行。该进程一直运行到完成或发生阻塞后才放弃CPU，唤醒后会重新进入就绪队列的队尾。
- **算法优点**：实现简单，只需要一个队列(FIFO)，且相当公平
- **算法缺点**：比较有利于长进程，而不利于短进程，有利于CPU密集的进程，而不利于I/O密集的进程

##### (2)短进程优先（SPF, Shortest Process First）
算法原理：从就绪队列中选出一个估计运行时间最短的进程，将CPU分配给它，该进程一直运行到完成或发生阻塞后才放弃CPU。
算法优点：缩短进程的等待时间，提高系统的吞吐量。
算法缺点：对长进程不利，可能长时间得不到执行；未能依据进程的紧迫程度来划分执行的优先级；难以准确估计进程的执行时间，从而影响调度性能。

##### (3)高响应比优先法(HRRN，Highest Response Ratio Next)
- **算法原理**：优先权=响应比=(等待时间+执行时间)/执行时间，选择响应比最大者先执行；新来的具有更高优先级。
- **抢占式**：会立即终止当前进程；非抢占式：等当前进程完成或阻塞
- **算法优点**：兼顾了长短作业、到达先后
- **算法缺点**：每次调度前要计算响应比，增加系统开销。

##### (4)时间片轮转算法（RR，Round-Robin）
- **算法原理**：就绪进程按先后顺序在就绪队列中排队，在一个时间片结束时，发生时钟中断，调度程序暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。
- **算法优点**：简单易行、平均响应时间短。
- **算法缺点**：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大

##### (5)多级反馈队列(Multilevel Feedback Queue)
UNIX操作系统采取的便是这种调度算法  

**多级反馈队列调度算法描述：**
- ①进程首先进入优先级最高的队列等待；
- ②先从优先级高的队列中调度进程，若高优先级队列中没有进程，则从次优先级队列中调度进程；
- ③对于同一个队列中的各个进程，按照时间片轮转法调度。若时间片用完后作业还不能完成，进入下一级队列，直至完成；
- ④低优先级队列中的进程在运行时，有新进程进入较高优先级队列，立即停止当前进程，并放回当前队列尾部，CPU马上分配给新的进程（抢占式）。
- 优点：性能较好，能满足长短作业、交互型作业

### 7. 页面置换算法
#### 背景：
①在“大的”虚拟内存上进行分段，映射到“较小”物理内存上（打散）进行分页；运行虚拟内存上某段指令或使用数据前，先将从磁盘取，换入到物理内存，由逻辑地址映射到物理地址，CPU再取指令完成。由于虚拟内存较大，反复换入新的页，必然需要将物理内存中旧的页换出。根据页面置换算法选择换出的旧页。  
②一个程序访问内存，某些局部会反复访问（可能因为循环语句、全局变量...）——程序局部性原理  
③虚拟内存可能是在磁盘上，根据逻辑地址计算得到虚拟地址，按照“虚拟地址”去磁盘上读取“数据”，根据这个“数据”到“物理内存”取指令运行

##### (1)先进先出(FIFO)页面置换算法
> 总是淘汰最先进入内存的页面——与进程实际运行的规律不相适应，有些页面经常被访问

##### (2)最近最少使用(LRU)置换算法
> 利用栈实现，栈的容量有限，每当访问一个页，将页号压栈，若栈中有此页号，将原此页号调入栈顶；栈满时，会将栈底元素是最久未被访问的页，被置换出。

##### (3)Clock置换算法
> 利用环形链表实现，每页设置访问位R（0=未访问，1=已访问），某页被访问，R置1；
> 指针依次扫描链表，若该页R=1，置0，继续扫描；若该页R=0，换出该页，调入页插入当前位置；
> 如果记录的历史信息太长，退化为FIFO，改进：利用快指针定时清除R位，慢指针选择淘汰页

### 9. 怎么理解CPU中的缓存
##### cpu缓存
> 由程序执行的局部性原理，将内存中一些经常访问的信息存放在高速缓存中，减少访问内存的次数，可大幅度提高程序执行速度。

##### 分布式缓存
> 在分布式系统中提供缓存加速数据访问，减小数据库的访问压力。因为二八定律，将热点数据缓存。

### 10. 怎么理解内存碎片？什么是内部碎片？什么是外部碎片？
- **内存碎片**：内存分配过程中产生的，不能供新的进程使用的内存中的小分区。
- **内部碎片**：已分给某个进程的，由于分配按一定倍数，比如按页分配，最后一页中未使用的部分。
- **外部碎片**：还没有分给具体进程，由于太小，无法分配给申请内存空间的新进程的空闲区域，比如夹在两个页之间。
> 内存碎片=内部碎片+外部碎片


