- [1. OSI模型、TCP/IP模型以及每层对应的协议](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#1-osi%E6%A8%A1%E5%9E%8Btcpip%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%AF%8F%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE)
- [2. DNS(Domain Name System)解析](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#2-dnsdomain-name-system%E8%A7%A3%E6%9E%90)
- [3. HTTP协议（报头字段的作用，如cace-control、keep-alive）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#3-http%E5%8D%8F%E8%AE%AE%E6%8A%A5%E5%A4%B4%E5%AD%97%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%A6%82cace-controlkeep-alive)
- [4. http中GET和POST的区别](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#4-http%E4%B8%ADget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB)
- [5. https和http区别](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#5-https%E5%92%8Chttp%E5%8C%BA%E5%88%AB)
- [6、cookie和session的区别（可扩展到分布式session服务器）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#6cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8Fsession%E6%9C%8D%E5%8A%A1%E5%99%A8)
- [7. 服务端session是如何标识已登录的用户的？](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#7-%E6%9C%8D%E5%8A%A1%E7%AB%AFsession%E6%98%AF%E5%A6%82%E4%BD%95%E6%A0%87%E8%AF%86%E5%B7%B2%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%9A%84)
- [8. session是存储在什么地方，以什么形式存储的？](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#8-session%E6%98%AF%E5%AD%98%E5%82%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E4%BB%A5%E4%BB%80%E4%B9%88%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84)
- [9、负载均衡——将请求分发到不同服务器上去响应，让每个服务器的负载达到均衡的状态](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#9%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%B0%86%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%8E%BB%E5%93%8D%E5%BA%94%E8%AE%A9%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E8%BE%BE%E5%88%B0%E5%9D%87%E8%A1%A1%E7%9A%84%E7%8A%B6%E6%80%81)
- [10、session一致性——集群服务器session同步](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#10session%E4%B8%80%E8%87%B4%E6%80%A7%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8session%E5%90%8C%E6%AD%A5)
- [11、如果有万级别的session，怎么提高效率？](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#11%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%87%E7%BA%A7%E5%88%AB%E7%9A%84session%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87)
- [12、打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，越详细越好）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#12%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B6%B5%E7%9B%96%E4%BA%86%E5%90%84%E4%B8%AA%E6%96%B9%E9%9D%A2dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8Bnginx%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BF%9D%E6%8C%81%E8%BF%87%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD)
- [13、UDP、TCP报头格式](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#13udptcp%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F)
- [14、TCP/UDP区别（不仅是宏观上，最好能根据各自的机制讲解清楚）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#14tcpudp%E5%8C%BA%E5%88%AB%E4%B8%8D%E4%BB%85%E6%98%AF%E5%AE%8F%E8%A7%82%E4%B8%8A%E6%9C%80%E5%A5%BD%E8%83%BD%E6%A0%B9%E6%8D%AE%E5%90%84%E8%87%AA%E7%9A%84%E6%9C%BA%E5%88%B6%E8%AE%B2%E8%A7%A3%E6%B8%85%E6%A5%9A)
- [15、TCP的连接管理——三次握手、四次挥手（各种WAIT状态也要掌握）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#15tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%84%E7%A7%8Dwait%E7%8A%B6%E6%80%81%E4%B9%9F%E8%A6%81%E6%8E%8C%E6%8F%A1)
- [16、TCP如何保证数据的可靠传输的（拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#16tcp%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%85%A2%E5%BC%80%E5%A7%8B%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E5%BF%AB%E9%87%8D%E4%BC%A0%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E6%9C%80%E5%A5%BD%E9%83%BD%E8%83%BD%E6%8E%8C%E6%8F%A1)
- [17、IP子网划分](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#17ip%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86)
- [18、ARP（Address Resolution Protocol）地址解析协议——设备通过自己知道的IP地址来获得自己不知道的物理地址的协议](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#18arpaddress-resolution-protocol%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E7%9F%A5%E9%81%93%E7%9A%84ip%E5%9C%B0%E5%9D%80%E6%9D%A5%E8%8E%B7%E5%BE%97%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8D%8F%E8%AE%AE)
- [19、 RARP逆地址解析协议——设备不知道它自己的IP地址，但是知道自己的物理地址](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#19-rarp%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E8%AE%BE%E5%A4%87%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84ip%E5%9C%B0%E5%9D%80%E4%BD%86%E6%98%AF%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80)
- [20、交换机和路由器的区别](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#20%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB)
- [21、假如服务端知道客户端IP，服务端能否向客户端发消息？](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#21%E5%81%87%E5%A6%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9F%A5%E9%81%93%E5%AE%A2%E6%88%B7%E7%AB%AFip%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%83%BD%E5%90%A6%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E6%B6%88%E6%81%AF)
- [22、计算机相互之间的通信](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#22%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E4%BA%92%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1)
- [23、DHCP协议](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#23dhcp%E5%8D%8F%E8%AE%AE)
- [24、路由算法](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#24%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95)
- [25、加密](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#25%E5%8A%A0%E5%AF%86)





### 1. OSI模型、TCP/IP模型以及每层对应的协议

![网络结构](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.PNG)

**（1）应用层：特定的应用程序负责处理用户数据，应用程序通过这一层访问网络**
- SMTP(简单邮件传输协议)：命令/响应交互模式；基于TCP进行email消息的可靠传输
- DNS(域名系统)：查询和回复
- FTP(文件传输协议)
- HTTP(超文本传输协议)
- POP3(邮局协议)
- DHCP(动态主机配置协议)：报文封装到UDP数据报中  

**（2）传输层：负责提供端到端的通信，即提供应用程序之间的逻辑通信（通过端口号指定）**
- UDP(用户数据协议)：提供无连接通信，且不对传输包进行可靠性确认
- TCP(传输控制协议)：为应用程序提供面向连接的可靠通信 

**（3）网络层：主要是路由与转发，即提供主机之间的逻辑通信**
- IP(网络协议)：负责在主机和网络之间的路径寻址和数据包路由。
- ARP(地址解析协议)：获得同一物理网络中的主机硬件地址
- ICMP(因特网控制消息协议)：向发送端报告错误或异常
- NAT(网络地址转换)：属接入广域网(WAN)技术，将私有（保留）地址转换为合法IP地址的技术
- IGMP(因特网组管理协议)  

**（4）数据链路层：负责数据帧的发送和接收**
- MAC(多路访问控制协议)
- PPP(点到点协议)

### 2. DNS(Domain Name System)解析
**（1）DNS服务：**
- 域名和IP地址之间映射；
- 主机/服务器别名；
- 负载均衡（将网站的大流量访问映射到不同服务器）  

**（2）DNS是分布式系统**  
**（3）DNS解析过程**
- ① 如果系统中配置了 Hosts 文件，那么电脑会先查询 Hosts 文件，看这个域名否已经在 Hosts 里面有了对应的记录。如果有，直接就可以拿到该记录中的IP地址，过程就结束了；
- ② 主机向本地DNS服务器一般是递归查询：主机向本地域名服务器询问，本地域名服务器替代主机以DNS客户的身份向根域名服务器询问；
- ③ 本地DNS服务器向根DNS服务器一般是迭代查询：本地域名服务器向根域名服务器询问，本地域名服务器再向相应的顶级域名服务器询问，本地域名服务器再向相应权威域名服务器询问，本地域名服务器最后将查询结果告诉主机。 

![DNS解析](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/DNS%E8%A7%A3%E6%9E%90.PNG)

**（4）**  
- DNS欺骗 / DNS污染：冒充域名服务器，把查询的IP地址设为攻击者的IP地址。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了；
- DNS劫持：域名服务器上的某条记录被人为修改了，一旦查询这条记录，得到的就是错误的结果。

### 3. HTTP协议（报头字段的作用，如cace-control、keep-alive）
（1）**定义**：超文本传输协议是从万维网服务器（监听80端口）传输超文本到本地浏览器的应用层协议。  
（2）HTTP协议无状态——不维护客户端请求的历史信息  
（3）**HTTP协议的连接：** 
- http1.0：非持久性(短)连接——使用TCP短连接，服务器响应后断开连接
- http1.1：持久性连接——使用TCP长连接，服务器响应后将连接保持一段时间
- http1.1：流水线方式 / 非流水方式——接连发送新请求 / 收到响应才发请求

**（4）HTTP消息格式**  
&nbsp;&nbsp;&nbsp;&nbsp; 头部和消息体之间以一个回车换行隔开

![TCP报头格式1](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F1.PNG)

![TCP报头格式2](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F2.PNG)

**（5）HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）**  
&nbsp;&nbsp;&nbsp;&nbsp; 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

### 4. http中GET和POST的区别
- **操作影响**：get是从服务器上获取数据——get请求的数据不会修改服务器的状态；post是向服务器传送数据——post一般会改变服务器的状态
- **参数存放位置**：get的参数键值对在url地址栏明文发送；post将表单内键值对放置在http的头部，地址栏看不到
- **数据量**：get传送的数据量较小，不能大于2KB；post传送的数据量较大，一般不受限制。

### 5. https和http区别
**(1)https就是身披 SSL协议这层外壳的http**  
&nbsp;&nbsp;&nbsp;&nbsp; 通常，http直接和 TCP通信。  
&nbsp;&nbsp;&nbsp;&nbsp; 当使用 SSL 时，http先和SSL通信，再由SSL和TCP通信。  

**(2)SSL/TLS——同一东西的不同阶段**
- SSL(Secure Sockets Layer)：安全套接字层，不仅提供加密处理，还使用“证书”，以确定对方身份
- TLS(Transport Layer Security)：传输层安全协议

**(3)区别**
- https协议需要申请证书，一般免费证书较少，因而需要一定费用；
- http和https连接方式不同（多了身份验证、密钥传递等）；
- 默认端口不同，http是80，https是443；
- http的连接简单且是无状态的,信息是明文传输；https协议是由SSL+HTTP协议构建的可加密传输

### 6、cookie和session的区别（可扩展到分布式session服务器）
###### Cookie和session都是保存会话的技术：
- **存在位置**：cookie保存在客户端，session保存在服务器端；
- **功能**：cookie可以跟踪会话，也可以保存用户喜好或者用户名密码；session仅用来跟踪会话；
- **安全性**：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，session较安全；
- **性能**：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
###### 补充：token
- **token的认证流程**：用户登陆校验，校验成功后返回token给客户端——>客户端收到数据后保存在客户端——>客户端每次访问API/浏览器是携带token到服务器端——>服务器过滤校验，校验成功则返回请求数据，失败则返回错误数据。  
- **VS session：**  
    同：都是为了身份验证；都可以设置过期时间  
    异：session需要在服务端存储用户信息，token不需要；token需要算法和密钥加密揭秘验证（用时间换空间），session不需要（用空间换时间）。


### 7. 服务端session是如何标识已登录的用户的？
> http是无状态的会话，需要引入基于http协议支持会话状态的机制——session。在会话开始时，分配一个唯一的会话标识（sessionId），通过cookie把这个标识告诉浏览器，以后每次请求的时候，浏览器的cookie都会带上这个会话ID来告诉web服务器请求是属于哪个会话的。这也是为什么禁用cookie之后，每次操作都需要先登录。在web服务器上各个会话有独立的存储，保存不同会话的信息。

##### 对于上万个用于已经登录了，服务端是怎么分辨每个用户的？
- ① 服务器在响应头内加上”set-Cookie:XXXXXXXXXXXXX“(相当于一个唯一的ID符)，此信息是服务器随机生成的，放在服务器内存里，不会重复,这就是sessionid。
- ②当浏览器得到这个sessionId会将它放在自己的进程内存里,.然后你继续发请求给这个网站的时候,浏览器就会把这个sessionId放在请求头里发送给该服务器了,这样服务器得到sessionId后再和自己内存里存放的sessionid对比锁定客户端,从而区分不同客户端,完成会话。
- ③关闭浏览器结束进程,则这个sessionid将消失,如果用户又打开浏览器想继续这次会话的时候,就会因为发送的请求中没有这个sessionid，而使服务器无法辨别请求身份。


### 8. session是存储在什么地方，以什么形式存储的？
（1）session变量保存在web服务器中，你不能直接修改，当然，调用程序中的setAttribute()方法是可以的。cookie存储的不是具体的数据，要不岂不是太不安全了，谁都可以修改session变量了，网站也毫无安全性可言。实际，在cookie中，存储的是一个sessionId，它标示了一个服务器中的session变量，通过这种方式，服务器就知道你到底是那个session了。顺便说一句，如果客户端不支持cookie，session也是可以实现的，在服务器端通过urlEncoder，可以实现sessionId的传递——url重写。所以，记住客户端只存储session标识，实际内容在网页服务器中。  
（2）以键值对的方式存储的

### 9、负载均衡——将请求分发到不同服务器上去响应，让每个服务器的负载达到均衡的状态
#### （1）类型
##### ①http重定向负载均衡（属于应用层负载均衡 / 七层负载均衡）
- **做法**：一台普通的服务器——重定向服务器，其唯一的功能就是根据用户的HTTP请求计算一台应用集群中服务器的地址，并将此地址写入HTTP重定向响应中返回给用户  
- **优点**：实现简单；  
- **缺点**：浏览器需要每次请求两次服务器才能完成一次访问，性能较差。

##### ②DNS域名解析负载均衡（属于应用层负载均衡 / 七层负载均衡）
- **做法**：DNS中配置多个A记录，每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回  
- **优点**：将负载均衡工作交给DNS，省略掉了网络管理的麻烦  
- **缺点**：DNS是多级解析，每一级都会缓存DNS记录；如果服务器变动，DNS记录需要更新，更新较慢  


##### ③反向代理负载均衡（属于应用层负载均衡 / 七层负载均衡）
- **反向代理**（Reverse Proxy）：是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。  
- **做法**：反向代理服务器在HTTP协议层面转发请求  
- **优点**：部署简单  
- **缺点**：反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈  

##### ④四层负载均衡（传输层负载均衡）
- **做法**：接受到客户端请求后，通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器

##### ⑤三层负载均衡（网络层负载均衡）
- **做法**： 负载均衡服务器对外依然提供一个VIP（虚IP），但集群中不同的机器采用不同的IP地址。  
&nbsp;&nbsp;&nbsp;&nbsp; 客户端——>负载均衡服务器(将请求数据包中目的IP地址改为集群中某服务器IP地址)——>web服务器  
- &nbsp;&nbsp;&nbsp;&nbsp; 客户端<——负载均衡服务器(将响应数据包中源IP地址改为自身IP)<——某web服务器  
- **优点**：IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。
- **缺点**：负载均衡的网卡带宽成为系统的瓶颈。

##### ⑥二层负载均衡（数据链路层负载均衡）
- **做法**：负载均衡服务器对外提供一个VIP（虚拟IP），集群中不同的机器采用相同IP地址，但机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。  
- **优秀**：避免负载均衡服务器网卡带宽成为瓶颈，是目前大型网站所使用的最广的一种负载均衡手段。  

#### （2）常见的负载均衡算法
##### ①轮询法：
轮询很容易实现，将请求按顺序轮流分配到后台服务器上，均衡的对待每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

##### ②随机法：
通过系统随机函数，根据后台服务器列表的大小值来随机选取其中一台进行访问

##### ③源地址哈希法：
源地址哈希法的思想是根据服务消费者请求客户端的IP地址，通过哈希函数计算得到一个哈希值，将此哈希值和服务器列表的大小进行取模运算，得到的结果便是要访问的服务器地址的序号。

##### ④加权轮询法：
给配置高、负载低的机器分配更高的权重，使其能处理更多的请求，而配置低、负载高的机器，则给其分配较低的权重，降低其系统负载

##### ⑤加权随机法：
按照权重来随机选取服务器的，而非顺序

##### ⑥最小连接法（最佳）：
之前尽量做到请求次数的均衡——并不代表负载的均衡。
根据后端服务器当前的连接情况，动态的选取其中当前积压连接数最少的一台服务器来处理当前请求。

### 10、session一致性——集群服务器session同步
背景：高并发请求通过负载均衡分发到集群的某个服务器，如果同一用户的多次请求被分发到集群的不同服务器，如何保证服务端定位到session，保持会话——session一致性问题
#### （1）session复制 / session同步


![session复制](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/session%E5%A4%8D%E5%88%B6.PNG)
 
- **思路**：多个web-server之间相互同步session，这样每个web-server之间都包含全部的session  
- **优点**：web-server支持的功能，应用程序不需要修改代码  
- **不足**：session的同步需要数据传输，占内网带宽，有时延  ；所有web-server都包含所有session数据，数据量受内存限制；有更多web-server时要歇菜
#### （2）客户端存储
 
![session客户端存储](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/session%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8.PNG)

- **思路**：服务端存储所有用户的session，内存占用较大，可以将session存储到浏览器cookie中，每个端只要存储一个用户的数据了   
- **优点**：服务端不需要存储  
- **缺点**：每次http请求都携带session，占外网带宽；数据存储在客户端，并在网络传输，存在泄漏、篡改、窃取等安全隐患；session存储的数据大小受cookie限制。

#### （3）反向代理hash一致性（session绑定）

![session反向代理](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/session%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.PNG)

- **思路**：服务器为了保证高可用，有多台冗余，反向代理层能不能做一些事情，让同一个用户的请求保证落在一台服务器上呢?  
&nbsp;&nbsp;&nbsp;&nbsp; ①四层代理hash：反向代理层使用用户IP来做hash，以保证同一个IP的请求落在同一个服务器上  
&nbsp;&nbsp;&nbsp;&nbsp; ②七层代理hash：反向代理使用http协议中的某些业务属性来做hash，例如sessionid，user_id等，能够更加灵活的实施hash策略，以保证同一个浏览器用户的请求落在同一个web-server上  
  
- **优点**：只需要改nginx配置，不需要修改应用代码  
负载均衡，只要hash属性是均匀的，多台web-server的负载是均衡的
&nbsp;&nbsp;&nbsp;&nbsp; 可以支持web-server水平扩展（session同步法是不行的，受内存限制）  
- **不足**：  
    &nbsp;&nbsp;&nbsp;&nbsp; 如果web-server重启，一部分session会丢失，产生业务影响，例如部分用户重新登录   
    &nbsp;&nbsp;&nbsp;&nbsp; 如果web-server水平扩展，rehash后session重新分布，也会有一部分用户路由不到正确的session  
    &nbsp;&nbsp;&nbsp;&nbsp; session一般是有有效期的，所有不足中的两点，可以认为等同于部分session失效，一般问题不大。  
    &nbsp;&nbsp;&nbsp;&nbsp;
    对于四层hash还是七层hash，个人推荐前者：让专业的软件做专业的事情，反向代理就负责转发，尽量不要引入应用层业务属性。  

#### （4）后端统一集中存储

![session后端存储](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/session%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8.PNG)

 
- **思路**：将session存储在web-server后端的存储层，数据库或者缓存  
- **优点**：没有安全隐患  
&nbsp;&nbsp;&nbsp;&nbsp; 可以水平扩展，数据库/缓存水平切分即可  
&nbsp;&nbsp;&nbsp;&nbsp; web-server重启或者扩容都不会有session丢失  
- **不足**：增加了一次网络调用，并且需要修改应用代码
  
对于db存储还是cache，个人推荐后者：session读取的频率会很高，数据库压力会比较大。如果有session高可用需求，cache可以做高可用，但大部分情况下session可以丢失，一般不需要考虑高可用。

### 11、如果有万级别的session，怎么提高效率？
专门的session服务器(redis或则memcache实现)  
Note：引出session在分布式环境下的问题，引出一致性hash问题。  
分布式系统：建立在网络上的软件系统  
高可用性：通常来描述一个系统经过专门的设计，从而减少停工时间。
### 12、打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，越详细越好）
（1）浏览器查询缓存，如果缓存存在跳到第11步；  
（2）浏览器查看本地的host文件，是否存在对应IP地址；否则DNS域名解析，返回IP地址给浏览器   
（3）传输层，将http请求添加源和目的端口变为TCP段，发起对服务器的TCP连接；   
（4）网络层，将TCP段添加源和目的IP地址变为IP报，通过路由表确定如何到达服务器；  
（5）链路层，将IP报添加源和目的MAC地址变为MAC帧，通过ARP表确定去往的路由器；   
（6）通过CDN（放置反向代理节点服务器构成内容分发网络，将用户的请求重新导向离用户最近的服务节点上）去往缓存服务器，如果有缓存，直接返回；  
（7）否则，经过负载均衡服务器(将请求具体分配到某个实际处理服务器)，到达应用服务器  
（8）浏览器检查返回的HTTP响应是否是正常处理（2xx）；如果响应可缓存，将存入缓存  
（9）浏览器解码响应；浏览器展现响应  

note：这个题目其实是一个很好引导面试官的题目，说完大致过程之后，可以选择自己熟悉地方引。比如  
（1）关于负载均衡，引导负载均衡的类型以及实现负载均衡的算法；  
（2）比如session定位问题，引出session绑定、session复制、session服务器集群；  
（3）比如关于缓存我们可以引出二八定律、一致性hash问题。  
### 13、UDP、TCP报头格式

![TCP报头格式1](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F1.PNG)
  
序号(序列号)：当前segment第一个字节的编号，不是代表第几个segment  ；
ACK、RST、SYN、FIN：都是1bit，与连接建立有关；  
确认号：ack；  
 
![TCP报头格式2](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F2.PNG) 
 
加了伪首部（12个字节：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度）的TCP报头：为了计算校验和——所以传输层其实能拿到源、目IP地址  
### 14、TCP/UDP区别（不仅是宏观上，最好能根据各自的机制讲解清楚）
#### TCP服务，比如FTP文件传输、SMTP邮件
- 面向连接——客户机/服务器进程间需要建立连接  
- 传输可靠——不丢包  
- 报文长度——根据接收方窗口大小和网络拥塞程度决定报文段字节数，可能分割，报头有数据偏移  
- 流模式——用于一次传输大量数据  
- 开销大——建立连接需要较多时间，系统资源  
- 流量控制——发送方不会发送速度过快，超过接收方的处理能力  
- 拥塞控制——网络负载过重时，能够限制发送方的发送速度  
- 无低延迟保障——网游需要低延迟  
- 无带宽保障——弹性应用email适应任何带宽   
- 全双工——同一连接中能够传输双向数据流

#### TCP编程的服务器端一般步骤是： 
（1）创建一个socket，用函数socket()；  
（2）设置socket属性，用函数setsockopt(); * 可选   
（3）绑定IP地址、端口等信息到socket上，用函数bind();   
（4）开启监听，用函数listen()；   
（5）接收客户端上来的连接，用函数accept()；  
（6）收发数据，用函数send()和recv()，或者read()和write();   
（7）关闭网络连接；   
（8）关闭监听；  
### TCP编程的客户端一般步骤是： 
（1）创建一个socket，用函数socket()；  
（2）设置socket属性，用函数setsockopt();* 可选  
（3）绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
（4）设置要连接的对方的IP地址和端口等属性；   
（5）连接服务器，用函数connect()；  
（6）收发数据，用函数send()和recv()，或者read()和write();   
（7）关闭网络连接；  

### UDP服务，比如QQ
- 无连接  
- 无可靠性保障  
- 报文长度——由应用程序决定，既不合并也不拆分  
- 数据包模式——用于一次传输少量数据  
- 速度快  
- 无流量控制  
- 无拥塞控制  
- 无低延迟保障  
- 无带宽保障  


### UDP编程的服务器端一般步骤是： 
（1）创建一个socket，用函数socket()；  
（2）设置socket属性，用函数setsockopt();* 可选  
（3）绑定IP地址、端口等信息到socket上，用函数bind();   
（4）循环接收数据，用函数recvfrom();   
（5）关闭网络连接；  
### UDP编程的客户端一般步骤是： 
（1）创建一个socket，用函数socket()；  
（2）设置socket属性，用函数setsockopt();* 可选   
（3）绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
（4）设置对方的IP地址和端口等属性;   
（5）发送数据，用函数sendto();  
（6）关闭网络连接；  

### 15、TCP的连接管理——三次握手、四次挥手（各种WAIT状态也要掌握）
- **ACK**：TCP协议规定连接建立后所有发送的报文的ACK必须为1    
- **SYN**：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。  
- **FIN**：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

![TCP三次握手](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.PNG)

 
（1）由 Client 发出请求连接即SYN=1，ACK=0；TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此声明自己的序号是 seq=x  
（2）Server 进行回复确认，即 SYN=1，ACK=1，seq=y，ack=x+1  
（3）Client 再进行一次确认，但不用SYN  了，这时ACK=1，seq=x+1，ack=y+1，连接建立。  
连接是三次的原因：
为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B  发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B ，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。

![TCP四次挥手](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.PNG)

 
##### 客户端和服务端均可主动发起挥手操作终止连接：
（1）主动方A发送一个FIN(终止信号)给被动方B，表示要终结主动方A到被动方B的连接；  
（2）被动方B收到了FIN信号，返回ACK信号给主动方，表示从主动方到被动方的连接关闭了，也就是主动方不能再发送数据给被动方。  
（3）被动方B在发送完数据后，给主动方A发送一个FIN信号，请求终结被动方B到主动方A的连接；  
（4）主动方A收到了FIN信号，返回ACK信号给被动方B，表示从被动方B到主动方A的连接关闭了，也就是被动方不能再发送数据给主动方。  
##### **断开是四次的原因**：  
这是由于TCP的半关闭造成的，由于TCP 是全双工的，可以同时在两个方向上接收数据、发送数据。所以我们关闭连接必须在每个方向上单独关闭，这个单方向的关闭就叫半关闭。所以挥手时其实就是2次断开连接，所以是四次。
##### 主动方要等待2MSL（最大报文段寿命Maximum Segment Lifetime）时间的原因：
- 第一，保证A发送的最后一个ACK报文段能到达B。若丢失，B会重传FIN+ACK报文段，A在2MSL时间内收到此报文段，并重传一次确认，重新启动2MSL计时器。如果不等待一段时间，A就不能收到B重传的FIN+ACK报文段，也就不会再发送一次确认报文段，B也就无法按照正常步骤进入CLOSED状态。  
- 第二，使本连接持续的时间内所产生的所有报文段都从网络中消失，下一个新连接中不会出现旧的连接请求的报文段。
- 所以，B结束TCP连接时间比A早一些。

### 16、TCP如何保证数据的可靠传输的（拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握） 

![TCP可靠传输](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.PNG)

![滑动窗口协议](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.PNG)

### 17、IP子网划分

![IP子网划分](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.PNG)

![私有IP地址](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80.PNG)

### 18、ARP（Address Resolution Protocol）地址解析协议——设备通过自己知道的IP地址来获得自己不知道的物理地址的协议
ARP是解决同一局域网中的主机或路由器的IP地址和硬件地址的映射问题  
结点（主机或路由）维护ARP表，存储映射关系：IP-MAC-存活时间  
源A已知目的B的IP地址（由用户在应用层指定），为获知B的MAC地址：  
##### （1）A、B在同一局域网内：  
A广播发送ARP查询，包含B的IP地址、MAC地址=FF-FF-FF-FF-FF-FF；  
所有结点接收ARP查询，IP地址匹配成功的B向A单播发送它的MAC地址；  
A的ARP表中缓存B的IP-MAC，超时后刷新。  
##### （2）A、B不在同一局域网内：
A需知与外网相连的路由器的IP地址（由默认网关）  
A需知与外网相连的路由器的MAC地址（由ARP协议）  
- ①A在网络层构造IP数据报，源IP地址：A的IP地址，目的IP地址：B的IP地址  
- ②A在链路层构造帧，源MAC地址：A的MAC地址，目的MAC地址：网关的MAC地址  
- ③网关接收帧，提取IP数据报，传给上层IP协议，网关转发IP数据报（源和目的IP地址不变），网关在链路层构造帧，源MAC地址：网关的另一MAC地址，目的MAC地址：B的MAC地址  


### 19、 RARP逆地址解析协议——设备不知道它自己的IP地址，但是知道自己的物理地址
网络上的无盘工作站就是这种情况，RARP规定只有RARP服务器能产生应答。  
**工作流程**：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。



### 20、交换机和路由器的区别
两者都是存储转发设备，均使用转发表  
（1）工作层次不同：路由器是网络层设备(检测网络层分组首部)；交换机是链路层设备(检测链路层帧的首部)；  
（2）数据转发依据的对象不同：路由表是利用路由算法(路由协议)计算(设置)，依据IP地址；交换表利用自学习、泛洪构建转发表，依据MAC地址；  
（3）是否可以分割广播域：传统交换机只能分割冲突域，不能分割广播域；路由器可以分割广播域  
第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。

### 21、假如服务端知道客户端IP，服务端能否向客户端发消息？
不能，客户端接受消息是通过从服务器拉数据的形式来获取数据而不是服务器向客户端推送数据。客户端几乎也是不会监听端口接受服务器发来的消息。

### 22、计算机相互之间的通信
互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。  
> TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。  
> TCP 负责应用软件之间的通信，IP 负责计算机之间的通信。TCP 负责将数据分割并装入IP 包，IP负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。

**（1）IP（Internet Protocol  网际协议）：计算机之间的通信（路由转发）**  
每台计算机都有一个IP用来在Internet上标识这台计算机。
IP负责在因特网上发送和接收数据包：数据被分割为小的独立的包，并通过因特网在计算机之间传送，IP负责将每个包路由至它的目的地。  
IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP。

**（2）TCP（Transmission Control Protocol**  传输控制协议）：应用程序之间的通信（端到端通信）  
TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引入端口（port），它允许计算机通过网络提供各种服务。  
**服务端**：在提供服务的机器上，有程序（守护进程）监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于www的HTTP通信流出现在80端口上。  
**客户端**：当应用程序希望通过TCP与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工的通信，占用两个计算机之间整个的通信线路。

### 23、DHCP协议

![DHCP协议](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/DHCP%E5%8D%8F%E8%AE%AE.PNG)
 
 
### 24、路由算法

![路由算法](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95.PNG)

 
### 25、加密

![加密](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/%E5%8A%A0%E5%AF%86.PNG)
 
#### MD5算法：
- **S1**: 
&nbsp;&nbsp;&nbsp;&nbsp; 对消息进行填充，使消息的长度对512取模得448  
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 填充方法：在消息后面进行填充，填充第一位为1，其余为0.  
- **S2**: 
&nbsp;&nbsp;&nbsp;&nbsp;S1之后，再填充上原消息的长度，可用来进行的存储长度为64位，如果消息长度大于64，则只使用其低64位的值。（最终消息长度是512的整数倍） 
- **S3**：
&nbsp;&nbsp;&nbsp;&nbsp;消息以512分组，每一个分组进行四轮变换。

![MD5算法](https://github.com/daxiaoHe-Girls/daxiaoHe-Girls.github.io/blob/master/images/images_network/MD5%E7%AE%97%E6%B3%95.PNG)














